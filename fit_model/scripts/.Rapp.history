matrix(kk, ncol=length(Ha))
exp(0.5)
exp(-0.5)
exp(-ln(0.5))
exp(-log(0.5))
exp(-log(1/0.5))
kk = unlist(apply(Htable, 1, function(x){exp(-log(1/0.5)*x[2]/x[1])}))
matrix(kk, ncol=length(Ha))
image(Ha, Hv, matrix(kk, ncol=length(Ha)), col=rev(heat.colors(10)))
summary(kk)
hist(kk)
Ptable = expand.grid(Ha, Hv, PT)
PT = seq(0,1,0.1)
Ptable = expand.grid(Ha, Hv, PT)
kk = unlist(apply(Htable, 1, function(x){x[3]*exp(-log(1/0.5)*x[2]/x[1])}))
split(kk, Ptable$Ha)
head(kk)
kk
Ptable
kk = unlist(apply(Ptable, 1, function(x){x[3]*exp(-log(1/0.5)*x[2]/x[1])}))
kk
head(PTable)
head(Ptable)
kk[Ptable[,1]==1]
sel = kk[Ptable[,1]==1]
sel = Ptable[,1]==1
plot(Ptable[sel,3], kk[sel])
kk = unlist(apply(Ptable, 1, function(x){x[3]*(exp(-log(1/0.5)*x[2]/x[1])-0.5) + 0.5}))
plot(Ptable[sel,3], kk[sel])
sel = Ptable[,2]==1
plot(Ptable[sel,3], kk[sel])
sel = Ptable[,2]==0
plot(Ptable[sel,3], kk[sel])
sel = Ptable[,1]==0
plot(Ptable[sel,3], kk[sel])
PT = seq(0,1,0.1)Ptable = expand.grid(Ha, Hv, PT)kk = unlist(apply(Ptable, 1, function(x){x[3]*(exp(-log(1/0.5)*(1-x[1])/(1-x[2])-0.5) + 0.5}))
kk = unlist(apply(Ptable, 1, function(x){x[3]*(exp(-log(1/0.5)*((1-x[1])/(1-x[2]))-0.5) + 0.5}))
kk = unlist(apply(Ptable, 1, function(x){x[3]*(exp(-log(1/0.5)*((1-x[1])/(1-x[2])))-0.5) + 0.5}))
sel = Ptable[,1]==1
plot(Ptable[sel,3], kk[sel])
sel = Ptable[,1]==0
plot(Ptable[sel,3], kk[sel])
x <- c("A and B", "A, B and C", "A, B, C and D", "foobar")#
pattern <- "[[:space:]]*(,|and)[[:space:]]"#
## Match data from regexpr()#
m <- regexpr(pattern, x)#
regmatches(x, m)#
regmatches(x, m, invert = TRUE)
x = "je suis; certaine que ;Temperature; peut marcher"
pattern = "([:alpha:])+;"
m = regexpr(pattern, x)
m
regmachtes(x,m)
regmatches(x,m)
pattern = "([:alpha:])+;"
x
pattern = "[:alpha:]+;"
m = regexpr(pattern, x)
m
regmatches(x,m, invert=T)
pattern = "[[:alpha:]]+;"
m = regexpr(pattern, x)
m
regmatches(x,m, invert=T)
regmatches(x,m, invert=F)
pattern = "[[:a-zA-z:]]+;"
m = regexpr(pattern, x)
pattern = "[[:a-zA-Z:]]+;"
m = regexpr(pattern, x)
pattern = "[[:alpha:]]+;"
m = regexpr(pattern, x)
m
regmatches(x,m, invert=T)
regmatches(x,m, invert=F)
pattern = "[[:alpha:]]+;"x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "([:alpha:])+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "([:alpha:])+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "([:alpha:])+;"#
m = regexpr(pattern, x)#
regmatches(x,m)x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
x = "je suis; certaine que ; Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
x = "je suis; certaine que ;temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
?regmatches
x = "je suis; certaine que ;temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = regexec(pattern, x)#
regmatches(x,m)
x = "je suis certaine que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = regexpr(pattern, x)#
regmatches(x,m)
m
x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = grep(pattern, x)#
regmatches(x,m)
m
m = gregexpr(pattern, x)
m
regmatches(x,m)
x = "je suis; certaine que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = grep(pattern, x)#
regmatches(x,m)x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = gregexpr(pattern, x)#
regmatches(x,m)x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = gregexpr(pattern, x)#
regmatches(x,m)
x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher"#
pattern = "[[:alpha:]]+;"#
m = gregexpr(pattern, x)#
regmatches(x,m)
m
regexec([[0-9]], x)
regexec("[0-9]", x)
x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher 45°"#
pattern = "[[:alpha:]]+;"#
m = gregexpr(pattern, x)#
regmatches(x,m)
regexec("[0-9]", x)
regexpr("[0-9]", x)
regexpr("[0-9]", x)+1
x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher 45°"#
pattern = "[[:alpha:]]+;"#
m = gregexpr(pattern, x)#
regmatches(x,m[m<regexpr("[0-9]", x)])
m
m[which(m<regexpr("[0-9]", x)])
m<regexpr("[0-9]", x)
regexpr("[0-9]", x)
m
m[[1]]<regexpr("[0-9]", x)
m[which(m[[1]]<regexpr("[0-9]", x)])
m[which(m[[1]]<regexpr("[0-9]", x))]
which(m[[1]]<regexpr("[0-9]", x))
m[which(m[[1]]<regexpr("[0-9]", x))]
m[[1]][which(m[[1]]<regexpr("[0-9]", x))]
regmatches(x,m[[1]][which(m[[1]]<regexpr("[0-9]", x)]))
regmatches(x,m[[1]][which(m[[1]]<regexpr("[0-9]", x))])
x
m
x = strplit(x, regexpr("[0-9]", x))[[1]]
x = strsplit(x, regexpr("[0-9]", x))[[1]]
x
x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher 45°"#
x = strsplit(x, "[0-9]")[[1]]
x
x = "je suis; certaine; depuis 0 que ;Temperature; peut marcher 45°"#
x = strsplit(x, "[0-9]")[[1]][1]#
pattern = "[[:alpha:]]+;"#
m = gregexpr(pattern, x)#
regmatches(x,m)
load("../estimated_params/veget_m3_v2")
setwd('/Users/isabelle/Documents/RESEARCH/ANALYSES/2014_veget_herbi_dyn/FourSTModel/fit_model/scripts')
rm(list = ls())detach(params$best_par)#load("../estimated_params/veget_m3_v2")#source("4-init_params_v2.R")#params = coarse_veget#-- veget m3 refine likelihood ML= -3081.598load("../estimated_params/par_veget_m3_step6")source("4-init_params.R")load("../estimated_params/par_veget_m3_step6_lim")params = coarse_veget
cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
attach(params$best_par)tpseq=seq(min(data$ENV1)*1.1,max(data$ENV1)*1.1,length.out=100)ppseq=seq(min(data$ENV2)*1.1,max(data$ENV2)*1.1,length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,7), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab*(1-alphat))), type ="l", xlab = "T", ylab = "alphab", ylim = c(0,1))plot(lowess(cbind(ENV1, alphat*(1-alphab))), type ="l", xlab = "T", ylab = "alphat", ylim = c(0,1))plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "betab", ylim = c(0,1))plot(lowess(cbind(ENV1, betat)), type ="l", xlab = "T", ylab = "betat", ylim = c(0,1))plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "thetab", ylim = c(0,1))plot(lowess(cbind(ENV1, thetat)), type ="l", xlab = "T", ylab = "thetat", ylim = c(0,1))plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alphab", ylim = c(0,1))plot(lowess(cbind(ENV2, alphat)), type ="l", xlab = "PP", ylab = "alphat", ylim = c(0,1))plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "betab", ylim = c(0,1))plot(lowess(cbind(ENV2, betat)), type ="l", xlab = "PP", ylab = "betat", ylim = c(0,1))plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "thetab", ylim = c(0,1))plot(lowess(cbind(ENV2, thetat)), type ="l", xlab = "PP", ylab = "thetat", ylim = c(0,1))plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))#quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_m3.pdf")
load("../estimated_params/coarse_m3")source("4-init_params.R")
cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
coarse$best_par
rm(list = ls())detach(params$best_par)#load("../estimated_params/veget_m3_v2")#source("4-init_params_v2.R")#params = coarse_veget#
#-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3")source("4-init_params.R")params = coarse_veget
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=1000)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=1000)
ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_m3.pdf")
colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")
dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
-- herbivores m3 - esa ML=-3096.31load("../estimated_params/coarse_m3")source("4-init_params.R")load("../estimated_params/coarse_m3")#veget_pars = read.table("../estimated_params/par_herbivores_m3.txt")params = coarse
rm(list = ls())detach(params$best_par)
-- herbivores m3 - esa ML=-3096.31load("../estimated_params/coarse_m3")source("4-init_params.R")load("../estimated_params/coarse_m3")#veget_pars = read.table("../estimated_params/par_herbivores_m3.txt")params = coarse
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=1000)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=1000)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")
par(mfrow = c(2,7), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alphab", ylim = c(0,1))plot(lowess(cbind(ENV1, alphat)), type ="l", xlab = "T", ylab = "alphat", ylim = c(0,1))plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "betab", ylim = c(0,1))plot(lowess(cbind(ENV1, betat)), type ="l", xlab = "T", ylab = "betat", ylim = c(0,1))plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "thetab", ylim = c(0,1))plot(lowess(cbind(ENV1, thetat)), type ="l", xlab = "T", ylab = "thetat", ylim = c(0,1))plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alphab", ylim = c(0,1))plot(lowess(cbind(ENV2, alphat)), type ="l", xlab = "PP", ylab = "alphat", ylim = c(0,1))plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "betab", ylim = c(0,1))plot(lowess(cbind(ENV2, betat)), type ="l", xlab = "PP", ylab = "betat", ylim = c(0,1))plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "thetab", ylim = c(0,1))plot(lowess(cbind(ENV2, thetat)), type ="l", xlab = "PP", ylab = "thetat", ylim = c(0,1))plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alphab", ylim = c(0,1), col = "lightgreen")lines(lowess(cbind(ENV1, alphat)), type ="l", xlab = "T", ylab = "alphat", ylim = c(0,1), col = "darkgreen")
plot(ENV1, alphab, type ="l", xlab = "T", ylab = "alphab", ylim = c(0,1), col = "lightgreen")
lines(ENV1, alphat), type ="l", xlab = "T", ylab = "alphat", ylim = c(0,1), col = "darkgreen")
lines(ENV1, alphat, type ="l", xlab = "T", ylab = "alphat", ylim = c(0,1), col = "darkgreen")
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
legend("top", col = c("darkgreen","lightgreen"))
legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"))
legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
dev.copy2pdf(file = "../figures/params_herbivores.pdf")
-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3")source("4-init_params.R")params = coarse_veget
rm(list = ls())detach(params$best_par)
-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3")source("4-init_params.R")params = coarse_veget
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
dev.copy2pdf(file = "../figures/params_sansHerbivores.pdf")
rm(list = ls())detach(params$best_par)#load("../estimated_params/veget_m3_v2")#source("4-init_params_v2.R")#params = coarse_veget#
#-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3_step2")source("4-init_params.R")load("../estimated_params/coarse_veget_m3_step2_lim")params = coarse_veget
cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP#
#v2
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
?pop.proj
library(popbio)
?pop.projection
-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3_step2")source("4-init_params.R")load("../estimated_params/coarse_veget_m3_step2_lim")params = coarse_veget
rm(list = ls())detach(params$best_par)#load("../estimated_params/veget_m3_v2")#source("4-init_params_v2.R")#params = coarse_veget#
#-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3_step3")source("4-init_params.R")load("../estimated_params/coarse_veget_m3_step3_lim")params = coarse_veget
cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP#
#v2#  logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV2 + ab3*ENV1^2 + ab4*ENV2^2 +  ab5*ENV2*ENV1#    logit_alphat 	= at0 + at1*ENV1 + at2*ENV2 + at3*ENV1^2 + at4*ENV2^2 + at5*ENV2*ENV1#    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV2 + bb3*ENV1^2 + bb4*ENV2^2 + bb5*ENV2*ENV1#    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV2 + bt3*ENV1^2 + bt4*ENV2^2 + bt5*ENV2*ENV1#    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV2 + tb3*ENV1^2 + tb4*ENV2^2 + tb5*ENV2*ENV1#    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV2 + tt3*ENV1^2 + tt4*ENV2^2 + tt5*ENV2*ENV1#    logit_eps 	= e0  + e1*ENV1  + e2*ENV2 + e5*ENV2*ENV1##v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
rm(list = ls())detach(params$best_par)#load("../estimated_params/veget_m3_v2")#source("4-init_params_v2.R")
load("../estimated_params/coarse_m3_step2")source("4-init_params.R")load("../estimated_params/coarse_m3_step2_lim")#veget_pars = read.table("../estimated_params/par_herbivores_m3.txt")params = coarse#
##----------------cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]
names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
rm(list = ls())detach(params$best_par)
-- herbivores m3 - esa ML=-3096.31load("../estimated_params/coarse_m3_step3")source("4-init_params.R")load("../estimated_params/coarse_m3_step3_lim")#veget_pars = read.table("../estimated_params/par_herbivores_m3.txt")params = coarse
cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
10^2
10^7
rm(list = ls())detach(params$best_par)
-- herbivores m3 - esa ML=-3096.31load("../estimated_params/coarse_m3_step4")source("4-init_params.R")load("../estimated_params/coarse_m3_step4_lim")#veget_pars = read.table("../estimated_params/par_herbivores_m3.txt")params = coarse
cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))#
par(mfrow = c(2,4), mar = c(4,4,1,1), cex=0.8)plot(lowess(cbind(ENV1, alphab)), type ="l", xlab = "T", ylab = "alpha", ylim = c(0,1), col = "darkgreen")legend("top", col = c("darkgreen","lightgreen"), legend=c("B", "T"), bty="n", lwd=1)lines(lowess(cbind(ENV1, alphat)), col = "lightgreen")plot(lowess(cbind(ENV1, betab)), type ="l", xlab = "T", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, betat)),col = "lightgreen")plot(lowess(cbind(ENV1, thetab)), type ="l", xlab = "T", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV1, thetat)), col = "lightgreen")plot(lowess(cbind(ENV1, eps)), type ="l", xlab = "T", ylab = "eps", ylim = c(0,1))plot(lowess(cbind(ENV2, alphab)), type ="l", xlab = "PP", ylab = "alpha", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, alphat)), col = "lightgreen")plot(lowess(cbind(ENV2, betab)), type ="l", xlab = "PP", ylab = "beta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, betat)),col = "lightgreen")plot(lowess(cbind(ENV2, thetab)), type ="l", xlab = "PP", ylab = "theta", ylim = c(0,1), col = "darkgreen")lines(lowess(cbind(ENV2, thetat)), col = "lightgreen")plot(lowess(cbind(ENV2, eps)), type ="l", xlab = "PP", ylab = "eps", ylim = c(0,1))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
library(ade4)
dudi.mix
?dudi.mix
setwd('/Users/isabelle/Documents/RESEARCH/ANALYSES/2014_veget_herbi_dyn/FourSTModel/fit_model/scripts')
state transitionsdata = as.data.frame(read.table("../data/data_reshaped_RBTM_herbivores.txt"))# neighborhoodpred = read.table("../data/data_pred_states_multinom.txt")#pred = read.table("../data/data_pred_states_randomForest.txt")## remove transitions D->C and C->Dtest = numeric(nrow(data))test[data$st0 == "T" & data$st1 == "B"] = 1test[data$st0 == "B" & data$st1 == "T"] = 1data = subset(data, test!=1)pred = subset(pred, test!=1)data$ENV1 = data$annual_mean_tempdata$ENV2 = data$annual_pp/1000data$EB = pred$Bdata$ET = pred$Tdata$EM = pred$M data$Hv = data$deer*75/100 ## kg/hectaredata$Ha = data$moose*350/1000 ## kg/hectare#data$Hv = rep(0, nrow(data))#data$Ha = rep(0, nrow(data))
head(data)# Evaluate initial parameter valuestransitions = paste(data$st0,data$st1,sep = "")sum_transitions = table(transitions)tot_transitions = table(data$st0)# estimates for initial parameterseps_mn = # proba x->R given x is T B or M(sum_transitions["BR"]+sum_transitions["MR"]+sum_transitions["TR"])/(tot_transitions["M"] + tot_transitions["B"] + tot_transitions["T"])thetab_mn = # proba M-> B sum_transitions["MB"]/tot_transitions["M"]thetat_mn = # proba M->Tsum_transitions["MT"]/tot_transitions["M"]betab_mn = # proba T->Msum_transitions["TM"]*(tot_transitions["B"]+tot_transitions["M"])/tot_transitions["M"]/sum(tot_transitions)betat_mn = # proba B->Msum_transitions["BM"]*(tot_transitions["T"]+tot_transitions["M"])/tot_transitions["M"]/sum(tot_transitions)trRT = sum_transitions["RT"]/tot_transitions["R"]trRB = sum_transitions["RB"]/tot_transitions["R"]trRM = sum_transitions["RB"]/tot_transitions["R"]alphat_mn = trRM/((tot_transitions["M"]+tot_transitions["T"])*(trRB+trRM))alphab_mn = (trRB+trRM)/(tot_transitions["M"] + tot_transitions["B"])# transform into logitslogit_eps_mn = log(eps_mn/(1-eps_mn))logit_thetab_mn = log(thetab_mn/(1-thetab_mn))logit_thetat_mn = log(thetat_mn/(1-thetat_mn))#
logit_betab_mn = log(betab_mn/(1-betab_mn))logit_betat_mn = log(betat_mn/(1-betat_mn))logit_alphab_mn = log(alphab_mn/(1-alphab_mn))logit_alphat_mn = log(alphat_mn/(1-alphat_mn))
eps_mn
setwd('/Users/isabelle/Documents/RESEARCH/ANALYSES/2014_veget_herbi_dyn/FourSTModel/fit_model/scripts')
sum_transitions
transitions
st1
head(data)
toR = ifelse(data$st1=="R", 0, 1)
toR
mod = glm(toR~ ENV1 + I(ENV1^2) + ENV2 + I(ENV^2), family = "binomial")
mod = glm(toR~ ENV1 + I(ENV1^2) + ENV2 + I(ENV^2), family = "binomial", data=data)
mod = glm(toR~ ENV1 + I(ENV1^2) + ENV2 + I(ENV2^2), family = "binomial", data=data)
mod
plot(predict(mod)~ENV1)
plot(predict(mod)~data$ENV1)
plot(predict(mod)~data$ENV1)
?glm
toR
predict(mod)
mod = glm(cbind(toR, !toR)~ ENV1 + I(ENV1^2) + ENV2 + I(ENV2^2), family = "binomial", data=data)
predict(mod)
predict(mod, type = "function")
predict(mod, type = "response")
plot(predict(mod, type = "response")~data$ENV1)
plot(predict(mod, type = "response")~data$ENV2)
plot(toR, data$ENV1)
plot(lowess(cbind(data$ENV1, toR)))
plot(lowess(cbind(toR, data$ENV1)))
toR = ifelse(data$st1=="R", 1, 0)
toR[data$st0=="R"] = 0
toR
mod = glm(toR~ ENV1 + I(ENV1^2) + ENV2 + I(ENV2^2), family = "binomial", data=data)
plot(predict(mod, type = "response")~data$ENV1)
plot(toR~ENV1)
plot(toR~data$ENV1)
plot(lowess(cbind(data$ENV1, toR)))
plot(predict(mod, type = "response")~data$ENV2)
setwd('/Users/isabelle/Documents/RESEARCH/ANALYSES/2014_veget_herbi_dyn/FourSTModel/fit_model/scripts')
dat = read.table("../data/data_BA.txt",header = TRUE, sep = ";")#head(dat)dim(dat)## Rm all harvested plots dat  <- dat[-which(dat$disturbance%in%c("BRP", "CAM", "CB", "CD", "CDL", "CE", "CJ", "CP", "DLD", "EPC")),]dim(dat)# BRP = brulis partiel# CAM = coupe d'amélioration# CB = coupe par bandes# CD = coupes en damier# CDL = coupe à diamètre limité# CE = coupe partielle et épidémie légère# CHP = chablis partiel# CJ = coupe de jardinage# CP = coupe partielle# DLD = Coupe à diamètre limite avec dégagement des arbres d'avenir# DP  = Dépérissement partiel du feuillu# EL = Épidémie légère# EPC = Éclaircie précommerciale# VEP = Verglas partiel#
## Rm all plots with no climatic data associateddat  <- dat[which(!is.na(dat$annual_pp)),]dim(dat)## Conserve all plots with drainage 20 to 40dat <- dat[which(dat$drainage>=20 & dat$drainage<=40),]dim(dat)## rm plot with no coordinates constraintsdat <- dat[-which(dat$lon==0),]dim(dat)########################################################################                  Classify plots                       ########################################################################### List of interests speciesI_sp  <- c("bop","peb","peg","pet","prp","sal","soa")B_sp  <- c("epn","epb","epr", "mel","pig","sab") T_sp  <- c("boj", "chr", "err","ers","fra","frn","heg","osv","til","cet")# Subset species BA and cover type observedBA_dat <- c(which(colnames(dat)=="ame"): which(colnames(dat)=="til"))### Get BA by hectares (the plot is 400m2)dat[,BA_dat] <- dat[,BA_dat]*10000/400dat$I_tot  <- rowSums(dat[,which(colnames(dat) %in% I_sp)],na.rm=T)dat$B_tot  <- rowSums(dat[,which(colnames(dat) %in% B_sp)],na.rm=T)dat$T_tot  <- rowSums(dat[,which(colnames(dat) %in% T_sp)],na.rm=T)dat$BA_tot <- rowSums(dat[,BA_dat],na.rm=T)# Class into state typesclass_fn = function(x) {   Itot = x[1]; Btot =x[2]; Ttot=x[3]; BAtot=x[4]  classPlot = "Unclass"  if(BAtot < 10) classPlot = "R"  else if(Btot > 0 & Ttot == 0) classPlot = "B"  else if(Ttot > 0 & Btot == 0) classPlot = "T"  else if (Btot > 0 & Ttot > 0) classPlot = "M"return(classPlot)}dat$class_final  <- as.vector(apply(dat[,c("I_tot", "B_tot", "T_tot", "BA_tot")],1,class_fn))table(dat$class_final)
Clean data                     ##########################################################################dat = read.table("../data/data_BA.txt",header = TRUE, sep = ";")#head(dat)dim(dat)## Rm all harvested plots dat  <- dat[-which(dat$disturbance%in%c("BRP", "CAM", "CB", "CD", "CDL", "CE", "CJ", "CP", "DLD", "EPC")),]dim(dat)# BRP = brulis partiel# CAM = coupe d'amélioration# CB = coupe par bandes# CD = coupes en damier# CDL = coupe à diamètre limité# CE = coupe partielle et épidémie légère# CHP = chablis partiel# CJ = coupe de jardinage# CP = coupe partielle# DLD = Coupe à diamètre limite avec dégagement des arbres d'avenir# DP  = Dépérissement partiel du feuillu# EL = Épidémie légère# EPC = Éclaircie précommerciale# VEP = Verglas partiel#
## Rm all plots with no climatic data associateddat  <- dat[which(!is.na(dat$annual_pp)),]dim(dat)## Conserve all plots with drainage 20 to 40dat <- dat[which(dat$drainage>=20 & dat$drainage<=40),]dim(dat)## rm plot with no coordinates constraintsdat <- dat[-which(dat$lon==0),]dim(dat)########################################################################                  Classify plots                       ########################################################################### List of interests speciesI_sp  <- c("bop","peb","peg","pet","prp","sal","soa")B_sp  <- c("epn","epb","epr", "mel","pig","sab") T_sp  <- c("ers")# Subset species BA and cover type observedBA_dat <- c(which(colnames(dat)=="ame"): which(colnames(dat)=="til"))### Get BA by hectares (the plot is 400m2)dat[,BA_dat] <- dat[,BA_dat]*10000/400dat$I_tot  <- rowSums(dat[,which(colnames(dat) %in% I_sp)],na.rm=T)dat$B_tot  <- rowSums(dat[,which(colnames(dat) %in% B_sp)],na.rm=T)dat$T_tot  <- rowSums(dat[,which(colnames(dat) %in% T_sp)],na.rm=T)dat$BA_tot <- rowSums(dat[,BA_dat],na.rm=T)# Class into state typesclass_fn = function(x) {   Itot = x[1]; Btot =x[2]; Ttot=x[3]; BAtot=x[4]  classPlot = "Unclass"  if(BAtot < 10) classPlot = "R"  else if(Btot > 0 & Ttot == 0) classPlot = "B"  else if(Ttot > 0 & Btot == 0) classPlot = "T"  else if (Btot > 0 & Ttot > 0) classPlot = "M"return(classPlot)}dat$class_final  <- as.vector(apply(dat[,c("I_tot", "B_tot", "T_tot", "BA_tot")],1,class_fn))table(dat$class_final)#dat[dat$class_final=="Unclass",]
Clean data                     ##########################################################################dat = read.table("../data/data_BA.txt",header = TRUE, sep = ";")#head(dat)dim(dat)## Rm all harvested plots dat  <- dat[-which(dat$disturbance%in%c("BRP", "CAM", "CB", "CD", "CDL", "CE", "CJ", "CP", "DLD", "EPC")),]dim(dat)# BRP = brulis partiel# CAM = coupe d'amélioration# CB = coupe par bandes# CD = coupes en damier# CDL = coupe à diamètre limité# CE = coupe partielle et épidémie légère# CHP = chablis partiel# CJ = coupe de jardinage# CP = coupe partielle# DLD = Coupe à diamètre limite avec dégagement des arbres d'avenir# DP  = Dépérissement partiel du feuillu# EL = Épidémie légère# EPC = Éclaircie précommerciale# VEP = Verglas partiel#
## Rm all plots with no climatic data associateddat  <- dat[which(!is.na(dat$annual_pp)),]dim(dat)## Conserve all plots with drainage 20 to 40dat <- dat[which(dat$drainage>=20 & dat$drainage<=40),]dim(dat)## rm plot with no coordinates constraintsdat <- dat[-which(dat$lon==0),]dim(dat)########################################################################                  Classify plots                       ########################################################################### List of interests speciesI_sp  <- c("bop","peb","peg","pet","prp","sal","soa")B_sp  <- c("epn","epb","epr", "mel","pig","sab") T_sp  <- c("ers")# Subset species BA and cover type observedBA_dat <- c(which(colnames(dat)=="ame"): which(colnames(dat)=="til"))### Get BA by hectares (the plot is 400m2)dat[,BA_dat] <- dat[,BA_dat]*10000/400dat$I_tot  <- rowSums(dat[,which(colnames(dat) %in% I_sp)],na.rm=T)dat$B_tot  <- rowSums(dat[,which(colnames(dat) %in% B_sp)],na.rm=T)dat$T_tot  <- rowSums(dat[,which(colnames(dat) =="ers")],na.rm=T)dat$BA_tot <- rowSums(dat[,BA_dat],na.rm=T)# Class into state typesclass_fn = function(x) {   Itot = x[1]; Btot =x[2]; Ttot=x[3]; BAtot=x[4]  classPlot = "Unclass"  if(BAtot < 10) classPlot = "R"  else if(Btot > 0 & Ttot == 0) classPlot = "B"  else if(Ttot > 0 & Btot == 0) classPlot = "T"  else if (Btot > 0 & Ttot > 0) classPlot = "M"return(classPlot)}dat$class_final  <- as.vector(apply(dat[,c("I_tot", "B_tot", "T_tot", "BA_tot")],1,class_fn))table(dat$class_final)#dat[dat$class_final=="Unclass",]
colnames(dat)
Clean data                     ##########################################################################dat = read.table("../data/data_BA.txt",header = TRUE, sep = ";")#head(dat)dim(dat)## Rm all harvested plots dat  <- dat[-which(dat$disturbance%in%c("BRP", "CAM", "CB", "CD", "CDL", "CE", "CJ", "CP", "DLD", "EPC")),]dim(dat)# BRP = brulis partiel# CAM = coupe d'amélioration# CB = coupe par bandes# CD = coupes en damier# CDL = coupe à diamètre limité# CE = coupe partielle et épidémie légère# CHP = chablis partiel# CJ = coupe de jardinage# CP = coupe partielle# DLD = Coupe à diamètre limite avec dégagement des arbres d'avenir# DP  = Dépérissement partiel du feuillu# EL = Épidémie légère# EPC = Éclaircie précommerciale# VEP = Verglas partiel#
## Rm all plots with no climatic data associateddat  <- dat[which(!is.na(dat$annual_pp)),]dim(dat)## Conserve all plots with drainage 20 to 40dat <- dat[which(dat$drainage>=20 & dat$drainage<=40),]dim(dat)## rm plot with no coordinates constraintsdat <- dat[-which(dat$lon==0),]dim(dat)########################################################################                  Classify plots                       ########################################################################### List of interests speciesI_sp  <- c("bop","peb","peg","pet","prp","sal","soa")B_sp  <- c("epn","epb","epr", "mel","pig","sab") T_sp  <- c("ers","fra","frn","heg","osv","til","cet")# Subset species BA and cover type observedBA_dat <- c(which(colnames(dat)=="ame"): which(colnames(dat)=="til"))### Get BA by hectares (the plot is 400m2)dat[,BA_dat] <- dat[,BA_dat]*10000/400dat$I_tot  <- rowSums(dat[,which(colnames(dat) %in% I_sp)],na.rm=T)dat$B_tot  <- rowSums(dat[,which(colnames(dat) %in% B_sp)],na.rm=T)dat$T_tot  <- rowSums(dat[,which(colnames(dat) %in% T_sp)],na.rm=T)dat$BA_tot <- rowSums(dat[,BA_dat],na.rm=T)# Class into state typesclass_fn = function(x) {   Itot = x[1]; Btot =x[2]; Ttot=x[3]; BAtot=x[4]  classPlot = "Unclass"  if(BAtot < 10) classPlot = "R"  else if(Btot > 0 & Ttot == 0) classPlot = "B"  else if(Ttot > 0 & Btot == 0) classPlot = "T"  else if (Btot > 0 & Ttot > 0) classPlot = "M"return(classPlot)}dat$class_final  <- as.vector(apply(dat[,c("I_tot", "B_tot", "T_tot", "BA_tot")],1,class_fn))table(dat$class_final)#dat[dat$class_final=="Unclass",]
summaray(data$ENV1)
summary(data$ENV1)
summary(data$ENV2)
table(transitions)
setwd('/Users/isabelle/Documents/RESEARCH/ANALYSES/2014_veget_herbi_dyn/FourSTModel/fit_model/scripts')
rm(list = ls())detach(params$best_par)#load("../estimated_params/veget_m3_v2")#source("4-init_params_v2.R")#params = coarse_veget#
#-- veget m3 -- esa ML=-3103.965load("../estimated_params/coarse_veget_m3_step3")source("4-init_params.R")load("../estimated_params/coarse_veget_m3_step3_lim")params = coarse_veget
----------------cbind(unlist(par_lo), unlist(par_hi), unlist(params$best_par))#names(par_lo) = colnames(params$likeli)[-(1:3)]#names(par_hi) = colnames(params$likeli)[-(1:3)]head(params$likeli)par(mfrow = c(7,7), mar = c(2, 2, 2,1))for( i in colnames(params$likeli)[-(1:3)]){plot(params$likeli[,i], ylim = as.vector(unlist(c(par_lo[i], par_hi[i]))), main = i, pch=15)points(y=params$best_par[i], x=20, col=2, pch=19)}
setwd('/Users/isabelle/Documents/RESEARCH/ANALYSES/2014_veget_herbi_dyn/FourSTModel/fit_model/scripts')
attach(params$best_par)tpseq=seq(min(data$ENV1),max(data$ENV1),length.out=100)ppseq=seq(min(data$ENV2),max(data$ENV2),length.out=100)#tpseq=seq(0,6,length.out=100)#ppseq=seq(0.7,1.5,length.out=100)ENV = expand.grid(TP =tpseq , PP = ppseq)TP = ENV$TPPP = ENV$PPENV1 = TPENV2 = PP
v1    logit_alphab 	= ab0 + ab1*ENV1 + ab2*ENV1^2 + ab3*ENV2 + ab4*ENV2^2 + ab5*ENV1^3 + ab6*ENV2^3    logit_alphat 	= at0 + at1*ENV1 + at2*ENV1^2 + at3*ENV2 + at4*ENV2^2 + at5*ENV1^3 + at6*ENV2^3    logit_betab 	= bb0 + bb1*ENV1 + bb2*ENV1^2 + bb3*ENV2 + bb4*ENV2^2 + bb5*ENV1^3 + bb6*ENV2^3    logit_betat 	= bt0 + bt1*ENV1 + bt2*ENV1^2 + bt3*ENV2 + bt4*ENV2^2 + bt5*ENV1^3 + bt6*ENV2^3    logit_thetab	= tb0 + tb1*ENV1 + tb2*ENV1^2 + tb3*ENV2 + tb4*ENV2^2 + tb5*ENV1^3 + tb6*ENV2^3    logit_thetat	= tt0 + tt1*ENV1 + tt2*ENV1^2 + tt3*ENV2 + tt4*ENV2^2 + tt5*ENV1^3 + tt6*ENV2^3    logit_eps 	= e0  + e1*ENV1  + e2*ENV1^2 + e3*ENV2 + e4*ENV2^2 + e5*ENV1^3 + e6*ENV2^3alphab = exp(logit_alphab)/(1+exp(logit_alphab))alphat = exp(logit_alphat)/(1+exp(logit_alphat))betab = exp(logit_betab)/(1+exp(logit_betab))betat = exp(logit_betat)/(1+exp(logit_betat))thetab = exp(logit_thetab)/(1+exp(logit_thetab))thetat = exp(logit_thetat)/(1+exp(logit_thetat))eps = exp(logit_eps)/(1+exp(logit_eps))
ab = alphabat = alphatbb = betabbt = betattb = thetabtt = thetate = eps#
# Compute the first? eigenvalues for C and D as invadersinvT1 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e + sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT2 = -(ab^2*bb - ab^2*bt + 2*ab^2*e + ab^2*tb + ab^2*tt - ab*at*e - ab*bb*e + ab*bt*e - sqrt(-4*ab^4*at*e*tb + ab^4*bb^2 + 2*ab^4*bb*bt - 2*ab^4*bb*tb + 2*ab^4*bb*tt + ab^4*bt^2 - 2*ab^4*bt*tb + 2*ab^4*bt*tt + ab^4*tb^2 + 2*ab^4*tb*tt + ab^4*tt^2 + 2*ab^3*at*bb*e + 2*ab^3*at*bt*e + 4*ab^3*at*e^2*tb + 2*ab^3*at*e*tb + 2*ab^3*at*e*tt - 2*ab^3*bb^2*e - 4*ab^3*bb*bt*e + 2*ab^3*bb*e*tb - 2*ab^3*bb*e*tt - 2*ab^3*bt^2*e + 2*ab^3*bt*e*tb - 2*ab^3*bt*e*tt + ab^2*at^2*e^2 - 2*ab^2*at*bb*e^2 - 2*ab^2*at*bt*e^2 + ab^2*bb^2*e^2 + 2*ab^2*bb*bt*e^2 + ab^2*bt^2*e^2))/(2*ab^2)invT3 =  -ab + einvB1 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e + sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)invB2 = -at + einvB3 = (ab*at*e + at^2*bb - at^2*bt - 2*at^2*e - at^2*tb - at^2*tt - at*bb*e + at*bt*e - sqrt(ab^2*at^2*e^2 - 4*ab*at^4*e*tt + 2*ab*at^3*bb*e + 2*ab*at^3*bt*e + 4*ab*at^3*e^2*tt + 2*ab*at^3*e*tb + 2*ab*at^3*e*tt - 2*ab*at^2*bb*e^2 - 2*ab*at^2*bt*e^2 + at^4*bb^2 + 2*at^4*bb*bt + 2*at^4*bb*tb - 2*at^4*bb*tt + at^4*bt^2 + 2*at^4*bt*tb - 2*at^4*bt*tt + at^4*tb^2 + 2*at^4*tb*tt + at^4*tt^2 - 2*at^3*bb^2*e - 4*at^3*bb*bt*e - 2*at^3*bb*e*tb + 2*at^3*bb*e*tt - 2*at^3*bt^2*e - 2*at^3*bt*e*tb + 2*at^3*bt*e*tt + at^2*bb^2*e^2 + 2*at^2*bb*bt*e^2 + at^2*bt^2*e^2))/(2*at^2)#invT = invT2invT = apply(cbind(invT1, invT2, invT3), 1, function(x){x[which.max((x))]})#invB = invB1invB = apply(cbind(invB1, invB2, invB3), 1, function(x){x[which.max((x))]})# Interpret the invasability criterioncoexist = numeric(length(invT))# unisp#coexist[invT>0] = 3#coexist[invT<0] = 4##coexist[invB>0] = 2#coexist[invB<0] = 4###both# Reciprocal resistance (alternative stable states)coexist[invT<0 & invB<0  & (ab-e)>0 & (at-e)>0] = 1# Species B wins (instabilité au point B=0,T=kT + (ab-e)>0 et stabilité au point B=kB,T=0# coexist[invB>0 & invT<0 & (ab-e)>0] = 2#coexist[invB>0 & invT<0] = 2# Species T winscoexist[invB<0 & invT>0 & (at-e)>0] = 3#coexist[invB<0 & invT>0] = 3# Reciprocal invasibilitycoexist[invB > 0 & invT > 0 & (ab-e)>0 & (at-e)>0] = 4#coexist[invB > 0 & invT > 0] = 4#
# instabilité vers crash#coexist[] = 0#table(coexist)# Plot the resultsZ = matrix(coexist+1,nr = length(tpseq), nc = length(ppseq))quartz(width = 6, height = 6)colo = c("white","pink", "darkgreen", "lightgreen", "orange")layout(matrix(c(1,2),nr=2,nc=1,byrow=TRUE),heights = c(1,6))par(mar=c(0,0,0,0))plot(1, type = "n", axes=FALSE, xlab="", ylab="")#title(title,cex=2)legend("center",legend = c("other","AltSS","Boreal Wins","Temperate Wins","Coexistence"),fill = colo,bty = "n",horiz = TRUE,cex = 0.8)par(mar=c(5,5,0,2))image(tpseq,ppseq*1000,Z,xlab = "Mean annual temperature", ylab = "Annual precipitation (mm)", cex.lab = 1.5, cex.axis = 1.25, col = colo, breaks = c(0:5))#grey(c(0:3)/3))#dev.copy2pdf(file = "../figures/Coexistence_area_herbivores.pdf")#dev.copy2pdf(file = "../figures/Coexistence_area_sansHerbivores.pdf")
